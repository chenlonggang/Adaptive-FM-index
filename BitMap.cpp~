#include"BitMap.h"
#include<math.h>
#include<iostream>
using namespace std;
#define lookuptable
inline int popcnt(unsigned long long int x)
{
	x = x -((x & 0xAAAAAAAAAAAAAAAA)>>1);
	x = (x & 0x3333333333333333)+((x>>2) & 0x3333333333333333);
	x =((x+(x>>4)) & 0x0F0F0F0F0F0F0F0F);
	return (x*0x0101010101010101)>>56;
}

int blog(int x)
{
	int ans = 0;
	while(x>0)
	{
		ans++;
		x=x>>1;
	}
	return ans;
}

BitMap::BitMap(unsigned long long int * bitbuff,int bit_len,int level,int block_size,unsigned char label,void ** tables)
{
	this->data = bitbuff;
	this->bitLen = bit_len;
	this->memorysize = 0;
	this->level = level;
	this->block_size = block_size;
	this->block_width = blog(block_size);
	this->super_block_size = 16*block_size;
	this->label = label;
	left=NULL;
	right=NULL;
	superblock =NULL;
	block=NULL;
	coding_style=NULL;
	ZF=NULL;
	RF=NULL;
	ZB=NULL;
	RB=NULL;
	RE=NULL;
	
	if(data!=NULL)
	{
		this->ZF =(uchar *) tables[0];
		this->ZB =(uchar *) tables[1];
		this->RF =(uchar *) tables[2];
		this->RB =(uchar *) tables[3];
		this->RE =(uchar   *) tables[4];
		threshold = block_size*0.5;
		tail =bitLen%block_size;
		Coding();
		buff =NULL;
	}

}

int BitMap::SizeInByte()
{

	int size = 0;
	if(data!=NULL)
	{
		//return bitLen/8;
		size+= superblock->GetMemorySize();
		size+= block->GetMemorySize();
		size+= coding_style->GetMemorySize();
		size+= memorysize;
	
	}
	return size;
}


void BitMap::Coding()
{
	int u64Len =0;
	if(bitLen%64 == 0)
		u64Len = bitLen/64;
	else
		u64Len = bitLen/64+1;
	u64 * temp = new u64[u64Len];
	memset(temp,0,u64Len*8);

	int index = 0;
	int space=0;
	int step1 = block_size*16;
	int step2 = block_size;
	superblock = new InArray(2*(bitLen/step1)+2,blog(bitLen));
	block      = new InArray(2*(bitLen/step2)+2,blog(step1-step2));
	coding_style      = new InArray(bitLen/step2+1,3);

	//runsnum = new InArray(bitLen/step2+1,blog(step2));


	int rank=0;
	int bits =0;
	int firstbit=0;
	int lastbit=0;
	int rl_g=0;
	int runs = 0;
	int bit=0;
	int * runs_tmp = new int[block_size+1];
	int k=0;
	int old_k=0;
	int index2=0;

	//在劈开中间的runs时使用.
	int num=0;
	int left=0;
	int right=0;

	//前一个superblock的offset.
	//int pre_superblock_offset = 0;
	int pre_rank=0;
	int pre_space =0 ;
	superblock->SetValue(0,0);
	superblock->SetValue(1,0);
	block->SetValue(0,0);
	block->SetValue(1,0);
	while(index < bitLen)
	{
		rl_g = 0;
		bits = 0;
		firstbit = 0;
		runs = 0;
		firstbit = GetBit(data,index);
		memset(runs_tmp,0,(block_size+1)*4);
		k=0;
 		runs=0;
		while(bits < block_size && index < bitLen)
		{

			runs = GetRuns(data,index,bit);
			bits = bits +runs;
			if(bit ==1)
				rank=rank+runs;
			runs_tmp[k] = runs;
			k++;
		}
		
		if(bits > block_size)
		{
			int step =0;
			index = index -(bits - block_size);
			step = block_size+runs-bits;
			if(bit ==1)//rank要修改
				rank = rank -runs+step;
			runs_tmp[k-1] = step;
		}

		lastbit = (firstbit+k-1)%2;

		old_k = k;//保留原始的runs数.

		//劈开跨界的那个runs。
		//规则：>=threshold，左边,否则右边.
		num =0;
		left=0;
		right=0;
		for(int i=0;i<k;i++)
		{
			num += runs_tmp[i];
			if(num < threshold)
				continue;
			else
			{
				if(num ==threshold)
					break;
				else
				{
					for(int j=k-1;j>=i+1;j--)
						runs_tmp[j+1]=runs_tmp[j];
					left = threshold - (num - runs_tmp[i]);
					right = runs_tmp[i] - left;
					runs_tmp[i]=left;
					runs_tmp[i+1]=right;
					k++;
					break;
				}
			}
		}
		
		//负责计算按照gamma编码所需的空间
		//可以在上一个for循环中计算完成
		for(int i=0;i<k;i++)
			rl_g = rl_g + 2*blog(runs_tmp[i])-1;
/*
		if(runs_tmp[0]==threshold)
			rl_g = rl_g - (2*blog(threshold)-1);
		if(runs_tmp[k-1]==threshold)
			rl_g = rl_g - (2*blog(threshold)-1);
*/

		int thred=20;
		int len = min(rl_g,block_size-thred);

		//runsnum->SetValue((index-1)/block_size,old_k);
		if(old_k==1)
		{
			if(firstbit==0)//minority 0 : coding_style:1
				coding_style->SetValue((index-1)/block_size,1);
			else //minority 1: coding_style:2
				coding_style->SetValue((index-1)/block_size,2);
			space = space +0;
		}

		else if(len == (block_size-thred) || index == bitLen)//plain
		{
			coding_style->SetValue((index-1)/block_size,3);
			int j=0;
			int num=0;
			if(index == bitLen)
			{
				space = space + bits;
				j = (index-bits)/64;
				num = bits%64?bits/64+1:bits/64;
			}
			else
			{
				space = space + block_size;
				j = (index - block_size)/64;
				num = block_size/64;
			}
			for(int kk=0;kk<num;kk++,j++)
				BitCopy(temp,index2,data[j]);
		}

		else//rl_gamma
		{
			//等价于上面的分支判断
			coding_style->SetValue((index-1)/block_size,4+(firstbit<<1)+lastbit);

			space =space + rl_g;
			num =0;
			for(int i=0;i<k;i++)
			{
				//cout<<runs_tmp[i]<<endl;
				num += runs_tmp[i];
				if(num<=threshold)
					Append_GF(temp,index2,runs_tmp[i]);
				else
					Append_GB(temp,index2,runs_tmp[i]);
			}
			//cout<<old_k<<endl;
		}
	
		//打表顺序，superblock在前,block在后.
		if(index % step1 == 0)
		{
			pre_rank = rank;
			superblock ->SetValue(2*(index/step1),pre_rank);

			pre_space = space;
			superblock->SetValue(2*(index/step1)+1,pre_space);
		}
		if(index % step2 ==0)
		{
			block->SetValue(2*(index/step2),rank - pre_rank);
			block->SetValue(2*(index/step2)+1,space - pre_space);
		}
	}

	//释放runs_tmp
	delete [] runs_tmp;

	int u64_len_real = 0;
	if(space % 64==0)
		u64_len_real = space /64+1;
	else
		u64_len_real = space /64 +1+1;
	
	this->memorysize = u64_len_real*8;
	delete [] data;
	data = new u64[u64_len_real];

	memset(data,0,u64_len_real*8);
	memcpy(data,temp,(u64_len_real-1)*8);
	delete [] temp;

}



BitMap::~BitMap()
{
	if(left)
		delete left;
	if(right)
		delete right;
	delete [] data;
	delete superblock;
	delete block;
	delete coding_style;
}

int BitMap::Rank(int pos,int & bit)
{
	if(pos<0 || pos > bitLen)
	{
		cerr<<"BitMap::Rank(int pos,int &bits):error parmaters: (pos,bitLen) "<<pos<<" , "<<bitLen<<endl;
		exit(0);
	}
	int superblock_anchor=0;
	int block_anchor=0;
	int rank_base=0;
	int overloop = (pos+1)%block_size;
	int offset=0;
	int type=0;
	int index=0;
	//bit=0;
	
	if(overloop <=threshold || bitLen-(pos+1) <=tail)//左边
	{ 
		//cout<<"left"<<endl;
		block_anchor = (pos+1)/block_size;
		superblock_anchor = (pos+1)/super_block_size;
		rank_base = superblock->GetValue(superblock_anchor<<1)+block->GetValue(block_anchor<<1);
		offset = superblock->GetValue(1+(superblock_anchor<<1))+block->GetValue(1+(block_anchor<<1));
		type = coding_style->GetValue(pos/block_size);
		if(overloop==0)
		{
			switch(type)
			{
				case 1:bit=0;break;//minority 0
				case 2:bit=1;break;//minority 1
				case 3:bit=GetBit(data,offset-1);break;//plain
				case 4:bit=0;break;
				case 5:bit=1;break;
				case 6:bit=0;break;
				case 7:bit=1;break;
			}
			return rank_base;
		}
		
		index = (offset&0x3f);
		switch(type)
		{
			case 1:bit=0;break;
			case 2:bit=1;rank_base += overloop;break;
			case 3:rank_base += PlainF_Rank(data+(offset>>6),index,overloop,bit);break;
			case 4:
			case 5:rank_base += RLF_Rank(data+(offset>>6),index,overloop,0,bit);break;
			case 6:
			case 7:rank_base += RLF_Rank(data+(offset>>6),index,overloop,1,bit);break;
		}
		return rank_base;
	}
	else//右端
	{
		//cout<<"right"<<endl;
		block_anchor = (pos+1)/block_size+1;
		superblock_anchor = (pos+1)/super_block_size;
		if((block_anchor&0x0f)==0)
			superblock_anchor++;
		rank_base = superblock->GetValue(superblock_anchor<<1)+block->GetValue(block_anchor<<1);
		offset= superblock->GetValue(1+(superblock_anchor<<1))+block->GetValue(1+(block_anchor<<1))-1;
		type = coding_style->GetValue(pos/block_size);
		index = 63 - (offset&0x3f);
		switch(type)
		{
			case 1:bit=0;break;
			case 2:bit=1;rank_base-=(block_size-overloop);break;
			case 3:rank_base -= PlainB_Rank(data+(offset>>6),index,block_size-overloop,bit);break;
			case 4:rank_base -= RLB_Rank(data+(offset>>6),index,block_size-overloop,0,bit);break;
			case 5:rank_base -= RLB_Rank(data+(offset>>6),index,block_size-overloop,1,bit);break;
			case 6:rank_base -= RLB_Rank(data+(offset>>6),index,block_size-overloop,0,bit);break;
			case 7:rank_base -= RLB_Rank(data+(offset>>6),index,block_size-overloop,1,bit);break;
		}
		return rank_base;
	}
}


/*int BitMap::Rank(int pos,int & bit)
{
	if(pos < 0 || pos > bitLen)
	{
		return 0;
	}

	if((pos+1)%block_size!=0)
	{
		int block_anchor = (pos+1)/block_size;
		int superblock_anchor = (pos+1)/super_block_size;
		int type = coding_style->GetValue(pos/block_size);
		int Irank1 = superblock->GetValue(superblock_anchor*2);
		int offset1 = superblock->GetValue(superblock_anchor*2+1);
		int rank_base = rank1+block->GetValue(block_anchor*2);
		int offset = offset1 + block->GetValue(block_anchor*2+1);
		buff = data +(offset>>6);
		int overloop = (pos+1)%block_size ;
		int index = (offset &0x3f);
		int rank = 0;
		switch(type)
		{
			case 0:rank = RL0_Rank(buff,index,overloop,bit);break;
			case 1:rank = RL1_Rank(buff,index,overloop,bit);break;
			case 2:rank = Plain_Rank_F(buff,index,overloop,bit);break;
			case 3:rank = 0;bit=0;break;
			case 4:rank = overloop;bit = 1;break;
		}
		return rank_base + rank;
	}
	else
	{
		int rank1   = superblock->GetValue(((pos+1)/super_block_size)*2);
		int offset1 = superblock->GetValue((pos/super_block_size)*2+1);
		int rank = rank1 + block->GetValue(((pos+1)/block_size)*2);
		int offset = offset1 + block->GetValue((pos/block_size)*2+1);

		int index = (offset&0x3f);
		buff = data+(offset>>6);
		int type = coding_style->GetValue(pos/block_size);
		int overloop = block_size;
		switch(type)
		{
			case 0:bit=RL0_Bit(buff,index,overloop);break;
			case 1:bit=RL1_Bit(buff,index,overloop);break;
			case 2:bit=Plain_Bit_F(buff,index,overloop);break;
			case 3:bit=0;break;
			case 4:bit=1;break;
		}
		return rank;

	}
}
*/

/*
int BitMap::Rank(int pos)
{
	if (pos<0 || pos > bitLen)
	{
		cout<<"BitMap::Rank  error paramater"<<endl;
		cout<<pos<<" "<<bitLen<<endl;
		exit(0);
	}

	int block_anchor = (pos+1)/block_size;
	int superblock_anchor = (pos+1)/super_block_size;
	int type = coding_style->GetValue(pos/block_size);

	int rank1 = superblock->GetValue(superblock_anchor<<1);
	int offset1 = superblock->GetValue((superblock_anchor<<1)+1);
	int rank_base = rank1 + block->GetValue(block_anchor<<1);
	int offset    = offset1 + block->GetValue((block_anchor<<1)+1);
	
	buff = data + (offset>>6);
	int overloop = (pos+1)%block_size ;
	int index = (offset & 0x3f);
	if(overloop > 0)
	{
		if(type==0)
			return rank_base + RL0_Rank(buff,index,overloop);
		if(type==1)
			return rank_base + RL1_Rank(buff,index,overloop);
		if(type==2)
			return rank_base + Plain_Rank(buff,index,overloop);
		if(type==3)
			return rank_base;
		if(type==4)
			return rank_base + overloop;
	}
	return rank_base;
}
*/
int BitMap::Rank(int pos)
{
	if(pos<0 || pos > bitLen)
	{
		cerr<<"BitMapi::Rank(int pos),error parpater "<<pos<<" "<<bitLen<<endl;
		exit(0);
	//	return 0;
	}
	int type=coding_style->GetValue(pos/block_size);
	int block_anchor =(pos+1)/block_size;
	int superblock_anchor=(pos+1)/super_block_size;
	int overloop = (pos+1)%block_size;
	int rank_base=0;
	int offset=0;
	int index=0;
	if(overloop<=threshold || bitLen-(pos+1) <= tail)//左端
	{
		//block_anchor= (pos+1)/block_size;
		//superblock_anchor = (pos+1)/super_block_size;
		rank_base = superblock->GetValue(superblock_anchor<<1)+block->GetValue(block_anchor<<1);
		if(overloop==0)
			return rank_base;

		offset = superblock->GetValue(1+(superblock_anchor<<1))+block->GetValue(1+(block_anchor<<1));
		index = (offset&0x3f);
		switch(type)
		{
			case 1:break;
			case 2:rank_base+=overloop;break;
			case 3:rank_base += PlainF_Rank(data+(offset>>6),index,overloop);break;
			case 4:
			case 5:
			case 6:
			case 7:rank_base += RLF_Rank(data+(offset>>6),index,overloop,(type>>1)&0x01);break;
		}
		return rank_base;
	}
	else//右端
	{
		//block_anchor = (pos+1)/block_size+1;

		//superblock_anchor = (pos+1)/super_block_size;
		
		//if(block_anchor%16==0)
		block_anchor++;
		if((block_anchor&0x0f)==0)
			superblock_anchor++;

		rank_base = superblock->GetValue(superblock_anchor<<1)+block->GetValue(block_anchor<<1);
		offset = superblock->GetValue(1+(superblock_anchor<<1))+block->GetValue(1+(block_anchor<<1))-1;
		//type = coding_style->GetValue(pos/block_size);
		index = 63 - (offset&0x3f);
		switch(type)
		{
			case 1:break;
			case 2:rank_base -= (block_size - overloop);break;
			case 3:rank_base -= PlainB_Rank(data+(offset>>6),index,block_size-overloop);break;
			case 4:
			case 5:
			case 6:
			case 7:rank_base -= RLB_Rank(data+(offset>>6),index,block_size-overloop,type&0x01);
		}
		return rank_base;
	}
}


int BitMap::GetBit(u64 * data,int index)
{
//	int anchor = index/64;
//	int pos = 63-index%64;
//	return ((data[anchor] &(0x01ull<<pos))>>pos);
	return ((data[index>>6] &(0x01ull<<(63-(index&0x3f))))>>(63-(index&0x3f)));
}

//2014.5.8:16:53:这三段程序的性能相当.
int BitMap::GetRuns(u64 * data,int &index,int &bit)
{
/*
    bit = GetBit(data,index);
	index=index+1;
	int runs =1;
	int currentbit = 0;
	while(runs < block_size)
	{
		currentbit = GetBit(data,index);
		if(currentbit == bit)
			runs++;
		else
			break;
		index++;
	}
	return runs;
*/

	bit = GetBit(data,index);
	index = index +1;
	int totle_runs = 1;
	int runs=0;
	
	while(totle_runs < block_size)
	{
		u16 x= GetBits_F(data,index,16);//index不联动
		if(bit==1)
			x=(~x);
		runs = Zeros(x);
		totle_runs +=runs;
		index+=runs;
		if(runs < 16)
			break;
	}
	return totle_runs;


/*	这两个while的i性能相当
	bit= GetBit(data,index);
	index = index +1;
	int totle_runs = 1;
	int runs=0;
	while(totle_runs < block_size)
	{
		u64 x = GetBits(data,index,64);
		if(bit == 1)
			x= (~x);
		runs = zerostable[(x>>48)&0xffff];
		totle_runs +=runs;
		index+=runs;
		if(runs < 16)
			break;
		runs = zerostable[(x>>32)&0xffff];
		totle_runs +=runs;
		index+=runs;
		if(runs < 16)
			break;
		runs = zerostable[(x>>16)&0xffff];
		totle_runs +=runs;
		index+=runs;
		if(runs < 16)
			break;
		runs = zerostable[x&0xffff];
		totle_runs +=runs;
		index+=runs;
		if(runs < 16)
			break;
	}

	return totle_runs;
*/


}


//逆向gamma编码,index联动
void BitMap::Append_GB(u64 *temp,int &index,u32 value)
{
	int bits = blog(value);
	u64 y = (bit_reverse((u16)value)>>(16-bits));
	if(index%64 + bits < 65)
	{
		temp[index/64] = (temp[index/64] | (y<<(64-(index%64 + bits))));
	}
	else
	{
		int first = 64- index%64;
		int second= bits - first;
		temp[index/64] = (temp[index/64] | (y>>second));
		temp [index/64 +1] = (temp[index/64+1] | (y<<(64-second)));
	}
	index = index + 2*bits -1;

}

//正向gamma编码,index联动
void BitMap::Append_GF(u64 *temp,int &index,u32 value)
{
	u64 y=value;
	int zerosnum = blog(value)-1;
	index+=zerosnum;
	int onesnum = zerosnum+1;
	if(index%64 + onesnum < 65)
	{
		temp[index/64] = (temp[index/64] | (y<<(64-(index%64 + onesnum))));
	}
	else
	{
		int first = 64 - index%64;
		int second = onesnum - first;
		temp[index/64] = (temp[index/64] | (y>>second));
		temp [index/64 +1] = (temp[index/64+1] | (y<<(64-second)));
	}
	index = index + onesnum;
}
/*
//定长编码,index联动
void BitMap::Append_f(u64 * temp,int & index,u32 value)
{
	u64 y=value;
	if(index % 64 + block_width < 65)
	{
		temp[index/64] = (temp[index/64] | (y<<(64-(index%64 + block_width))));
	}
	else
	{
		int first  = 64 - index%64;
		int second = block_width - first;
		temp[index/64] = (temp[index/64] | (y>>second));
		temp [index/64 +1] = (temp[index/64+1] | (y<<(64-second)));
	}
	index = index + block_width;
}
*/

void BitMap::BitCopy(u64 * temp,int & index,u64 value)
{
	if(index%64!=0)
	{
		int first = 64 - index % 64;
		int second = 64 - first;
		temp[index/64] = (temp[index/64] | (value>>second));
		temp[index/64 + 1] = (temp[index/64+1] | (value<<first));
	}
	else
		temp[index/64]  = value;
	index = index +64;
}

//由压缩格式的0,1串buff的index位置开始, bits_num个bits内有几个1
int BitMap::RL0_Rank(u64 * buff ,int &index,int bits_num)
{
/*
	int rank = 0;
	int bits = 0;
	while(true)
	{
		bits=GammaDecode(buff,index);
		bits_num = bits_num - bits;
		if(bits_num<=0)
			return rank;
		bits=GammaDecode(buff,index);
		bits_num = bits_num - bits;
		rank = rank + bits;
		if(bits_num<=0)
			return rank + bits_num;
	}
*/

#ifndef lookuptable	 
	
	int rank = 0;
	int already = 0;
	u64 x= GetBits(buff,index,64);
	int bits = 0;
	while(true)cout<<rank<<" "<<bit<<endl;
	{
		bits =1+ (((int)zerostable[x>>48])<<1);

		already = already +bits;
		if(already > 64)
		{
			index = index + (already - bits);
			x = GetBits(buff,index,64);
			bits =1+ (((int)zerostable[x>>48])<<1);
			already = bits;
		}

		bits_num = bits_num - (x>>( 64 - bits));
		if(bits_num <= 0)
			return rank;
		x=(x<<bits);

		 bits =1+ (((int)zerostable[x>>48])<<1);
		 already = already +bits;
		 if(already > 64)
		 {
			 index = index + (already - bits);
			 x = GetBits(buff,index,64);
			 bits =1+ (((int)zerostable[x>>48])<<1);
			 already = bits;
		 }

		 bits_num = bits_num -(x>>( 64 - bits));
		 rank = rank + (x>>( 64- bits));
		 if(bits_num <= 0)
			 return rank + bits_num;
		 x = (x<<bits);
	}

#endif


#ifdef lookuptable	
	return RLF_Rank(buff,index,bits_num,0);
#endif
}


int BitMap::RL0_Rank(u64 * buff,int & index,int bits_num,int &bit)
{
	int rank = 0;
	int bit_count = 0;
	int bits = 0;
	while(true)
	{
		 bits=GammaDecode_F(buff,index);
		 bit_count = bit_count + bits;
		 if(bit_count >= bits_num)
		 {
			 bit = 0;
			 return rank;
		 }
		 bits=GammaDecode_F(buff,index);
		 bit_count = bit_count + bits;
		 rank = rank + bits;
		 if(bit_count >= bits_num)
		 {
			 bit = 1;
			 return rank - (bit_count-bits_num);
		 }
	}
}

int BitMap::RL0_Bit(u64 * buff,int & index,int bits_num)
{
	//int rank = 0;
	int bit_count =0;
	int bits = 0;
	while(true)
	{
		bits=GammaDecode_F(buff,index);
		bit_count = bit_count + bits;
		if(bit_count >= bits_num)
			return  0;
		bits=GammaDecode_F(buff,index);
		bit_count = bit_count + bits;
		if(bit_count >= bits_num)
			return 1;
	}
}


//
int BitMap::RL1_Rank(u64 * buff,int &index,int bits_num)
{
/*
	int rank = 0;
	int bit_count = 0 ;
	int  bits = 0;
	while(true)
	{
		bits = GammaDecode(buff,index);
		bit_count = bit_count + bits;
		rank = rank + bits;
		if(bit_count >= bits_num)
			return rank - (bit_count-bits_num);
		bits = GammaDecode(buff,index);
		bit_count = bit_count + bits;
		if(bit_count >= bits_num)
			return rank;
	}
*/
#ifndef lookuptable
	int rank = 0;
	int already = 0;
	u64 x = GetBits_F(buff,index,64);
	int bits = 0;
	while(true)
	{
		bits =1+ (((int)Zeros(x>>48))<<1);
		already = already +bits;
		if(already > 64)
		{
			index = index + (already - bits);
			x = GetBits_F(buff,index,64);
			bits =1+ (((int)Zeros(x>>48))<<1);
			already = bits;
		}
		bits_num = bits_num -(x>>( 64 - bits));
		rank = rank + (x>>( 64- bits));
		if(bits_num <= 0)
			return rank + bits_num;
		x = (x<<bits);

		bits =1+ (((int)Zeros(x>>48))<<1);
		already = already +bits;
		if(already > 64)
		{
			index = index + (already - bits);
			x = GetBits_F(buff,index,64);
			bits =1+ (((int)Zeros(x>>48))<<1);
			already = bits;
		}
		bits_num = bits_num - (x>>( 64 - bits));
		if(bits_num <= 0)
			return rank;
		x=(x<<bits);
	}

#endif

#ifdef lookuptable
	return RLF_Rank(buff,index,bits_num,1);
#endif 
}

int BitMap::RL1_Rank(u64 * buff,int &index,int bits_num,int & bit)
{
	int rank = 0;
	int bit_count = 0 ;
	int  bits = 0;
	while(true)
	{
		 bits = GammaDecode_F(buff,index);
		 bit_count = bit_count + bits;
		 rank = rank + bits;
		 if(bit_count >= bits_num)
		 {
			 bit = 1;
			 return rank - (bit_count-bits_num);
		 }
		 bits = GammaDecode_F(buff,index);
		 bit_count = bit_count + bits;
		 if(bit_count >= bits_num)
		 {
			 bit = 0;
			 return rank;
		 }
	}
}

int BitMap::RL1_Bit(u64 * buff,int &index,int bits_num)
{
	//int rank = 0;
	int bit_count = 0 ;
	int  bits = 0;
	while(true)
	{
		 bits = GammaDecode_F(buff,index);
		 bit_count = bit_count + bits;
		 if(bit_count >= bits_num)
			 return 1;
		 bits = GammaDecode_F(buff,index);
		 bit_count = bit_count + bits;
		 if(bit_count >= bits_num)
			 return 0;
	}
}

int BitMap::PlainF_Rank(u64 * buff,int &index,int bits_num)
{
	int bit=0;
	return PlainF_Rank(buff,index,bits_num,bit);
}

int BitMap::PlainF_Rank(u64 * buff,int &index,int bits_num,int &bit)
{
	if((index &0x3f) + bits_num < 65)
	{
		u64 temp = (buff[index>>6]<<(index&0x36))>>(64-bits_num);
		index = index + bits_num -1;
		bit =(buff[index>>6]>>(64-(index&64)))&0x01;
		return popcnt(temp);
	}
	int rank = 0;
	int head = 64 - (index&0x3f);
	u64 temp = (buff[index>>6]<<(index&0x3f));
	rank = rank + popcnt(temp);
	bits_num = bits_num - head;
	int times = bits_num>>6;
	int i=0;
	for(i=0;i<times;i++)
		rank = rank + popcnt(buff[i+(index>>6)+1]);
	if((bits_num&0x3f)!=0)
		rank = rank + popcnt((buff[i+(index>>6)+1] >> (64-(bits_num&0x3f))));
	index  = index + head + bits_num - 1;
	bit = ((buff[index>>6] & (0x01ull<<(63-(index&0x3f)))) >>(63-(index&0x3f)));
	return rank;
}

int BitMap::PlainF_Bit(u64 * buff,int &index,int bits_num)
{
	index = index + bits_num - 1;
	return (buff[index/64] & (0x01ull<<(63 - (index&0x3f)))) >>(63 - (index&0x3f));

}


int BitMap::PlainB_Rank(u64 *buff,int &index,int bits_num)
{
	int bit=0;
	return PlainB_Rank(buff,index,bits_num,bit);
}

int BitMap::PlainB_Rank(u64 * buff,int &index,int bits_num,int &bit)
{
	int rank=0;
	int head=0;
	int times=0;
	int i=0;
	u64 temp = 0;
	if(index%64 + bits_num < 65)
	{
		temp = ((*(buff-index/64))<<(64-bits_num-(index&0x3f)))>>(64-(index&0x3f));
		index = index + bits_num;
		bit = (*(buff-(index>>6))>>(index&0x3f))&0x01;
		return popcnt(temp);
	}
	rank =0;
	head =64-index%64;
	temp = *(buff-index/64);
	temp = (temp >> (64-head));
	
	rank= rank +popcnt(temp);

	bits_num = bits_num - head;
	times = bits_num/64;
	i=0;
	for(i=0;i<times;i++)
		rank = rank + popcnt(*(buff-i-1-index/64));
	if(bits_num%64!=0)
		rank = rank +popcnt(*(buff-i-1-index/64) & ((0x01ull<<(bits_num%64))-1));
	index = index + head + bits_num;
	bit = ((*(buff-(index>>6)) & (0x01ull<<(index & 0x3f))) >>(index &0x3f));
	return rank;
}


u16 BitMap::bit_reverse(u16 x)
{
	x = ((x & 0x5555) << 1) | ((x >> 1) & 0x5555);
	x = ((x & 0x3333) << 2) | ((x >> 2) & 0x3333);
	x = ((x & 0x0f0f) << 4) | ((x >> 4) & 0x0f0f);
	return ((x<< 8) | (x >> 8));
}
/*
u16 BitMap::Reverse(u16 x)
{
	return (((u16)RE[(uchar)x])<<8) | RE[x>>8];
}
*/
int BitMap::GammaDecode_B(u64 * buff,int & index)
{
	u32 x = GetBits_B(buff,index,32);
	int runs = ZB[x&((0x01<<16)-1)];
	index = index +2*runs + 1;
	return bit_reverse((x>>runs)&((0x01<<(runs+1))-1))>>(16-(runs+1));
}

int BitMap::GammaDecode_F(u64 * buff,int & index)
{
	u32 x = GetBits_F(buff,index,32);
	int runs = Zeros(x>>16);
	//int runs = 16 - blog(x>>16);
	int bits = (runs<<1)+1;
	index = index + bits;
	return x>>(32-bits);
}


u64 BitMap::GetBits_B(u64 * buff,int &index,int bits)
{
	if((index & 0x3f) + bits < 65)
	{	
	//	if(bits & 0x3f)
	//		return (*(buff-(index>>6)) >>(index & 0x3f)) & ((0x01ull<<bits)-1);
	//	return *(buff-(index>>6));
		return (*(buff-(index>>6))<<(64-(index&0x3f)-bits))>>(64-bits);
	}
	//int first  = 64 - (index &0x3f);
	//int second = bits-first;
	//u64 high = (*(buff-1- (index>>6)) & ((0x01ull<<second)-1))<<first;
	//return high + (*(buff-(index >>6))>>(64-first));
	return ((*(buff-1- (index>>6)) & ((0x01ull<<(bits+(index&0x3f)-64))-1))<<(64-(index&0x3f)))|(*(buff-(index >>6))>>(index&0x3f));
}

//从buff的index位置开始,读取bits位数据,返回.

u64 BitMap::GetBits_F(u64 * buff,int &index,int bits)
{
/*
	if((index & 0x3f) + bits < 65)
	{
		if(bits==64)
			return buff[index>>6];
		return (buff[index>>6] >>( 64 -((index&0x3f) + bits))) & ((0x01ull<<bits)- 1);
	}

	int first = 64 - (index&0x3f);
	int second = bits - first;
	u64 high = (buff[index>>6] & ((0x01ull<<first)-1)) << second;
	return high + (buff[(index>>6)+1]>>(64-second));
*/
	if((index & 0x3f)+bits < 65)
	{
		return (buff[index>>6]<<(index &0x3f))>>(64-bits);
	}
	//int first = 64-(index & 0x3f);
	//int second = bits - first;
	//u64 high = (buff[index>>6] & ((0x01ull<<first)-1)) << second;
	//return high + (buff[(index>>6)+1]>>(64-second));
	return (buff[index>>6] & ((0x01ull<<(64-(index & 0x3f)))-1)) << (bits+(index&0x3f)-64) | (buff[(index>>6)+1]>>(128-bits-(index&0x3f)));

}

int BitMap::GetZerosRuns(u64 * buff,int &index)
{
/*	int runs = 0;
	int bit=0;
	while(true)
	{
		bit=GetBit(buff,index);
//		cout<<bit<<" ";
		if(bit==0)
			runs++;
		else
			break;
		index++;
	}
//	cout<<endl;
	return runs;
*/
	
	u32 x = GetBits_F(buff,index,16);
	int runs = Zeros(x);
	index = index + runs;
	return runs;

}


void BitMap::Left(BitMap * left)
{
     this->left = left;
}


void BitMap::Right(BitMap * right)
{
     this->right = right;
}
 
unsigned char BitMap::Label()
{
    return label;
}


int BitMap::Load(loadkit & s)
{
	s.loadi32(level);
	s.loadu8(label);
	s.loadi32(bitLen);
	s.loadi32(block_size);
	block_width = blog(block_size);
	threshold = 0.5*block_size;
	tail=bitLen%block_size;
	s.loadi32(super_block_size);
	s.loadi32(memorysize);
	this->data=NULL;
	this->superblock=NULL;
	this->block=NULL;
	this->coding_style=NULL;
	if(memorysize!=0)
	{
		this->data = new u64[memorysize/8];
		s.loadu64array(data,memorysize/8);
	
		superblock = new InArray();
		superblock->load(s);
		
		block = new InArray();
		block->load(s);
		
		coding_style = new InArray();
		coding_style->load(s);
	}
    return 0;
}


int BitMap::Save(savekit & s)
{
	s.writei32(level);
	s.writeu8(label);
	s.writei32(bitLen);
	s.writei32(block_size);
	s.writei32(super_block_size);
	s.writei32(memorysize);
	if(memorysize!=0)
	{
		s.writeu64array(data,memorysize/8);
	
		superblock->write(s);
		block->write(s);
		coding_style->write(s);
	}
	return 0;
}


int BitMap::RLB_Rank(u64 * buff,int &index,int bits_num,int rl_type)
{

	int bit=0;
	return RLB_Rank(buff,index,bits_num,rl_type,bit);
}

int BitMap::RLB_Rank(u64 * buff,int &index,int bits_num,int rl_type,int &bit)
{
	int rank = 0;
	int r=0;
	int already =0;
	u64 x= GetBits_B(buff,index,64);
	int bits=0;
	int step=0;
	int runs=0;
	int runs_num=0;
	u64 mask =((0x01ull<<16)-1);
	u16 gamma=0;
	rl_type = 1 - rl_type;
	u32 anchor=0;
	if(bits_num>32)
	{
		while(true)
		{
			//anchor = (x&mask)<<2;
			anchor =((u32)Reverse(x&mask))<<2;
			//runs = RB[anchor];
			runs= RF[anchor];
			if(runs>0)
			{
				//step = RB[1+anchor];
				step = RF[1+anchor];
				already = already + step;
				if(already > 64)
				{
					index = index + (already - step);
					x = GetBits_B(buff,index,64);
					already =0;
					continue;
				}

				//bits = RB[2+anchor];
				bits = RF[2+anchor];
				//r= RB[3+anchor];
				r= RF[3+anchor];
				bits=(bits==0)?256:bits;
				if((runs_num & 0x01) ==rl_type)
					rank = rank +r;
				else
					rank = rank + ( bits-r);
				bits_num = bits_num - bits;
				runs_num = runs_num + runs;
				if(bits_num<=0)
					break;
				x = (x>>step);
			}
			else
			{
				//step = ZB[x&mask];//0的个数
				step = Zeros(Reverse(x&mask));
				already = already + 2*step+1;
				if(already > 64)
				{
					index = index + (already - (2*step+1));
					x= GetBits_B(buff,index,64);
					//step = ZB[x&mask];
					step = Zeros(Reverse(x&mask));
					already = 2*step+1;
				}
				gamma = Reverse((u16)(x>>step))>>(16-step-1);
				bits_num = bits_num - gamma;
				if((runs_num &0x01) ==rl_type)
					rank = rank + gamma;
				if(bits_num <=0)
				{

					if((runs_num &0x01)==rl_type)
					{
						//bit=1;
						bit = (bits_num==0)?0:1;
						return rank + bits_num;
					}
					else
					{
						//bit=0;
						bit = (bits_num==0)?1:0;
						return rank;
					}
				}
				runs_num++;
				step = 2*step+1;
				x=(x>>step);
			}
		}
	}

	index = index + (already - step);
	bits_num = bits_num + bits;
	runs_num = runs_num - runs;
	if((runs_num &0x01) ==rl_type)
		rank = rank - r;
	else
		rank = rank - (bits -r );
	already = 0;
	x = GetBits_B(buff,index,64);
	while(true)
	{
		//step = ZB[x&mask];//0的个数
		step = Zeros(Reverse(x&mask));
		already = already + 2*step+1;
		if(already > 64)
		{
			index = index + (already - (2*step+1));
			x= GetBits_B(buff,index,64);
			//step = ZB[x&mask];
			step = Zeros(Reverse(x&mask));
			already = 2*step+1;
		}
		gamma = Reverse((u16)(x>>step))>>(16-step-1);
		//gamma = RE[(x>>step)&mask]>>(15-step);
		bits_num = bits_num - gamma;
		if((runs_num &0x01) ==rl_type)
			rank = rank + gamma;
		if(bits_num <=0)
		{
			if((runs_num &0x01)==rl_type)
			{
				//bit =1;
				bit = (bits_num==0)?0:1;
				return rank + bits_num;
			}
			else
			{
				//bit=0;
				bit = (bits_num==0)?1:0;
				return rank;
			}
		}
		runs_num++;
		step = 2*step+1;
		x=(x>>step);
	}
}

int BitMap::RLF_Rank(u64 * buff,int &index,int bits_num,int rl_type)
{
/*	
	int bit=0;
	return RLF_Rank(buff,index,bits_num,rl_type,bit);
*/
	int rank=0;
	int r=0;
	int already = 0;
	u64 x = GetBits_F(buff,index,64);
	int bits = 0;//通过查找表可以解码的被编码的0,1串的长度
	int step = 0;//
	int runs =0 ;//本次解码的runs数目
	int runs_num = 0;//累计的runs数目
	rl_type = 1 - rl_type;
	u32 anchor=0;
	if(bits_num > 32)
	{
		while(true)
		{
			anchor = (x>>48)<<2;
			runs = RF[anchor];
			if(runs >0)
			{
				step = RF[1+anchor];
				already = already + step;
				if(already > 64)
				{
					index = index + (already -step);
					x = GetBits_F(buff,index,64);
					already = 0;
					continue;
				}
				bits = RF[2+anchor];
				r = RF[3+anchor];
				bits=(bits==0)?256:bits;
				if((runs_num & 0x01) ==rl_type)
					rank = rank + r;
				else
					rank = rank + ( bits-r);
				bits_num = bits_num - bits;
				runs_num = runs_num + runs;
				if(bits_num <=0)
					break;
				x = (x<<step);
			}
			else
			{
			//	cout<<"fuck"<<endl;
				step = 1 + (((int)Zeros(x>>48))<<1);
				already = already + step;
				if(already > 64)
				{
					index = index + (already - step);
					x = GetBits_F(buff,index,64);
					step = 1 + (((int)Zeros(x>>48))<<1);
					already = step;
				}
				bits_num = bits_num - (x>>( 64 - step));
				if((runs_num &0x01) ==rl_type)
					rank = rank + (x>>( 64 - step));
				if(bits_num <=0)
				{
					if((runs_num &0x01)==rl_type)
					{
						//bit=1;
						return rank + bits_num;
					}
					else
					{
						//bit=0;
						return rank;
					}
				}
				runs_num++;
				x = (x<<step);
			}
			
		}
	}

	//cout<<rank<<" "<<bits_num<<endl;
	index = index + (already - step);
	bits_num = bits_num + bits;
	runs_num = runs_num - runs;
	if((runs_num &0x01) ==rl_type)
		rank = rank - r;
	else
		rank = rank - (bits -r );
	already = 0;
	x = GetBits_F(buff,index,64);
	while(true)
	{
		step = 1+ (((int)Zeros(x>>48))<<1);
		already  = already + step;
		if(already > 64)
		{
			index = index + (already - step);
			x =GetBits_F(buff,index,64);
			step  = 1+ (((int)Zeros(x>>48))<<1);
			already = step;
		}
		bits_num = bits_num - (x>>( 64 - step));
		if((runs_num &0x01) ==rl_type)
			rank = rank + (x>>( 64 - step));
		if(bits_num <= 0)
		{
			//if(bits_num==0)
			//	cout<<"fuck"<<endl;
			if((runs_num&0x01)==rl_type)
			{
				//bit =1;
				return rank + bits_num;
			}
			else
			{
				//bit=0;
				return rank;
			}
		}
		runs_num++;
		x=(x<<step);
	}
}

int BitMap::RLF_Rank(u64 * buff,int &index,int bits_num,int rl_type,int &bit)
{
	int rank=0;
	int r=0;
	int already = 0;
	u64 x = GetBits_F(buff,index,64);
	int bits = 0;//通过查找表可以解码的被编码的0,1串的长度
	int step = 0;//
	int runs =0 ;//本次解码的runs数目
	int runs_num = 0;//累计的runs数目
	rl_type = 1 - rl_type;
	if(bits_num > 32)
	{
		while(true)
		{
			runs = RF[(x>>48)<<2];
			if(runs >0)
			{
				step = RF[1+((x>>48)<<2)];
				already = already + step;
				if(already > 64)
				{
					index = index + (already -step);
					x = GetBits_F(buff,index,64);
					already = 0;
					continue;
				}
				bits = RF[2+((x>>48)<<2)];
				r = RF[3+((x>>48)<<2)];
				bits=(bits==0)?256:bits;
				if((runs_num & 0x01) ==rl_type)
					rank = rank + r;
				else
					rank = rank + ( bits-r);
				bits_num = bits_num - bits;
				runs_num = runs_num + runs;
				if(bits_num <=0)
					break;
				x = (x<<step);
			}
			else
			{
			//	cout<<"fuck"<<endl;
				step = 1 + (((int)Zeros(x>>48))<<1);
				already = already + step;
				if(already > 64)
				{
					index = index + (already - step);
					x = GetBits_F(buff,index,64);
					step = 1 + (((int)Zeros(x>>48))<<1);
					already = step;
				}
				bits_num = bits_num - (x>>( 64 - step));
				if((runs_num &0x01) ==rl_type)
					rank = rank + (x>>( 64 - step));
				if(bits_num <=0)
				{
					if((runs_num &0x01)==rl_type)
					{
						bit=1;
						return rank + bits_num;
					}
					else
					{
						bit=0;
						return rank;
					}
				}
				runs_num++;
				x = (x<<step);
			}
			
		}
	}

	//cout<<rank<<" "<<bits_num<<endl;
	index = index + (already - step);
	bits_num = bits_num + bits;
	runs_num = runs_num - runs;
	if((runs_num &0x01) ==rl_type)
		rank = rank - r;
	else
		rank = rank - (bits -r );
	already = 0;
	x = GetBits_F(buff,index,64);
	while(true)
	{
		step = 1+ (((int)Zeros(x>>48))<<1);
		already  = already + step;
		if(already > 64)
		{
			index = index + (already - step);
			x =GetBits_F(buff,index,64);
			step  = 1+ (((int)Zeros(x>>48))<<1);
			already = step;
		}
		bits_num = bits_num - (x>>( 64 - step));
		if((runs_num &0x01) ==rl_type)
			rank = rank + (x>>( 64 - step));
		if(bits_num <= 0)
		{
			//if(bits_num==0)
			//	cout<<"fuck"<<endl;
			if((runs_num&0x01)==rl_type)
			{
				bit =1;
				return rank + bits_num;
			}
			else
			{
				bit=0;
				return rank;
			}
		}
		runs_num++;
		x=(x<<step);
	}
}

